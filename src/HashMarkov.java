

import java.util.*;

public class HashMarkov implements MarkovInterface {
protected String[] myWords;		// Training text split into array of words 
	protected Random myRandom;		// Random number generator
	protected int myOrder;			// Length of WordGrams used
    protected static String END_OF_TEXT = "*** ERROR ***"; 
    private HashMap<WordGram, ArrayList<String>> map = new HashMap<WordGram, ArrayList<String>>();
public HashMarkov() {
		this(3);
	}
    public HashMarkov(int order){
		myOrder = order;
		myRandom = new Random();
	}
    @Override
    public void setTraining(String text) {
        // TODO Auto-generated method stub
        myWords = text.split("\\s+");
        map.clear();
		HashMap<WordGram,ArrayList<String>> trainingMap = new HashMap<WordGram, ArrayList<String>>();
		
		for(int i = 0; i  < myWords.length-myOrder; i++){
			WordGram key = new WordGram(myWords, i, myOrder);
			if(i+myOrder == myWords.length){
				if(trainingMap.containsKey(key)){
					ArrayList<String> list =  trainingMap.get(key);
					trainingMap.put(key, list);
				}
				else{
					ArrayList<String> list = new ArrayList<String>();
					trainingMap.put(key, list);
				}
			}
			else{
				if(trainingMap.containsKey(key)){
					ArrayList<String> list =  trainingMap.get(key);
					list.add(myWords[i+myOrder]);
					trainingMap.put(key, list);
				}
				else{
					ArrayList<String> a = new ArrayList<String>();
					a.add(myWords[i+myOrder]);
					trainingMap.put(key, a);
				}
			}
			}
		map = trainingMap;
	}
    

    @Override
    public List<String> getFollows(WordGram wgram) {
        // TODO Auto-generated method stub
        if (!map.containsKey(wgram))
			throw new NoSuchElementException("This " + wgram + "does not exist in the map");
            else 
            {
		return map.get(wgram);
            }
        //throw new UnsupportedOperationException("Unimplemented method 'getFollows'");
    }

   
    /**
	 * Returns a random word that follows kGram in the training text.
	 * In case no word follows kGram, returns END_OF_TEXT
	 * @param wgram is being searched for in training text. Typically
	 * the previous words of the randomly generated text, but could be
	 * an arbitrary WordGram.
	 * @return a random word among those that follow after kGram in 
	 * the training text, or END_OF_TEXT if none
	 */
	private String getNextWord(WordGram wgram) {
		List<String> follows = getFollows(wgram);
		if (follows.size() == 0) {
			return END_OF_TEXT;
		}
		else {
			int randomIndex = myRandom.nextInt(follows.size());
			return follows.get(randomIndex);
		}
	}

	/**
	 * Generates length random words based on training text.
	 * Initial words are a random WordGram taken from the training text.
	 * Subsequent words are generated by calling getNext on the current
	 * WordGram, which is then shifted to include the newly generated 
	 * word at the end. Words are separated by spaces in returned string.
	 * @param length Number of words to generate
	 * @returns length randomly generated words using Markov model, 
	 * separated by spaces
	 */
	@Override
	public String getRandomText(int length){
		ArrayList<String> randomWords = new ArrayList<>(length);
		int index = myRandom.nextInt(myWords.length - myOrder + 1);
		WordGram current = new WordGram(myWords,index,myOrder);
		randomWords.add(current.toString());

		for(int k=0; k < length-myOrder; k += 1) {
			String nextWord = getNextWord(current);
			if (nextWord.equals(END_OF_TEXT)) {
				break;
			}
			randomWords.add(nextWord);
			current = current.shiftAdd(nextWord);
		}
		return String.join(" ", randomWords);
	}

    @Override
    public int getOrder() {
        // TODO Auto-generated method stub
        return myOrder;
       // throw new UnsupportedOperationException("Unimplemented method 'getOrder'");
    }

    @Override
    public void setSeed(long seed) {
        myRandom.setSeed(seed);
        // TODO Auto-generated method stub
       // throw new UnsupportedOperationException("Unimplemented method 'setSeed'");
    }

    
}
